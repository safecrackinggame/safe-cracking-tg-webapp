<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Safe Cracking TG</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow-x: hidden;
            transition: background-color 0.3s, color 0.3s;
        }
        .game-container {
            width: 100%;
            max-width: 420px;
            padding: 1rem;
            background-color: #ffffff;
            border-radius: 1.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            transition: background-color 0.3s, box-shadow 0.3s;
        }
        body.dark-mode {
            background-color: #1a202c;
            color: #e2e8f0;
        }
        .game-container.dark-mode {
            background-color: #2d3748;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.15);
        }
        .dark-mode .text-gray-700 { color: #cbd5e0; }
        .dark-mode .bg-gray-200 { background-color: #4a5568; }
        .dark-mode .bg-white { background-color: #2d3748; }
        .dark-mode .text-gray-500 { color: #a0aec0; }
        .dark-mode .bg-gray-50 { background-color: #1f2937; border-color: #4a5568; }
        .dark-mode .bg-blue-100 { background-color: #3b5a8d; color: #d1e0f7; }
        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .settings-bar {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .theme-toggle-btn, .sound-toggle-btn {
            padding: 0.5rem;
            border-radius: 9999px;
            transition: background-color 0.2s;
        }
        .theme-toggle-btn:hover, .sound-toggle-btn:hover {
            background-color: #e2e8f0;
        }
        .dark-mode .theme-toggle-btn:hover, .dark-mode .sound-toggle-btn:hover {
            background-color: #4a5568;
        }
        .digit-picker {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        .digit-slot {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
        }
        .digit-display {
            width: 2.5rem;
            height: 2.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #e2e8f0;
            border: 2px solid #d1d5db;
            border-radius: 0.5rem;
            font-size: 1.5rem;
            font-weight: bold;
            text-align: center;
        }
        .dark-mode .digit-display {
            background-color: #4a5568;
            border-color: #6b7280;
        }
        .digit-btn {
            background-color: #3b82f6;
            color: white;
            width: 1.5rem;
            height: 1.5rem;
            border-radius: 0.25rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .digit-btn:hover {
            background-color: #2563eb;
        }
        .digit-btn:disabled {
            background-color: #9ca3af;
            cursor: not-allowed;
        }
        .dark-mode .digit-btn {
            background-color: #1e40af;
        }
        .dark-mode .digit-btn:hover {
            background-color: #1e3a8a;
        }
        .dark-mode .digit-btn:disabled {
            background-color: #6b7280;
        }
    </style>
</head>
<body class="font-sans antialiased text-gray-800 bg-gray-100 flex items-center justify-center min-h-screen p-4 md:p-8">
    <div class="game-container bg-white rounded-2xl shadow-xl p-6 md:p-8 relative">
        <div class="top-bar">
            <div class="settings-bar">
                <select id="languageSelector" class="px-4 py-2 rounded-lg border border-gray-300 bg-white text-gray-800 focus:border-blue-500 focus:ring focus:ring-blue-200 cursor-pointer w-fit"></select>
            </div>
            <div class="settings-bar">
                <h1 class="text-3xl font-extrabold text-blue-600">
                    <span id="appTitle" data-translate="app_title">Safe Cracking</span>
                </h1>
                <button id="soundToggleBtn" class="sound-toggle-btn">
                    <svg id="soundOnIcon" class="w-6 h-6 text-gray-700 dark:text-white" fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path d="M3,9v6h4l5,5V4l-5,5H3z"/>
                        <path d="M13,6c2,2 2.5,4 2.5,6c0,2 -0.5,4 -2.5,6"/>
                        <path d="M15,5c2.5,2.5 3,5 3,7c0,2 -0.5,4.5 -3,7"/>
                        <path d="M17,3c3,3 3.5,6 3.5,9c0,3 -0.5,6 -3.5,9"/>
                    </svg>
                    <svg id="soundOffIcon" class="w-6 h-6 text-gray-700 dark:text-white hidden" fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path d="M3,9v6h4l5,5V4L7,9H3z" />
                    </svg>
                </button>
            </div>
            <div class="settings-bar">
                <select id="difficultySelector" class="px-4 py-2 rounded-lg border border-gray-300 bg-white text-gray-800 focus:border-blue-500 focus:ring focus:ring-blue-200 cursor-pointer w-fit"></select>
            </div>
        </div>
        <div id="stats" class="w-full text-center text-sm font-semibold text-gray-700">
            <p id="totalCoinsDisplay" class="text-xl font-bold text-green-600"></p>
            <p id="gamesPlayedDisplay"></p>
            <p id="rewardRangeDisplay" class="text-blue-500"></p>
            <p id="levelsCompletedDisplay" class="text-purple-600"></p>
        </div>
        <div id="gameArea" class="w-full flex flex-col items-center gap-4">
            <p id="messageDisplay" class="text-lg font-medium text-gray-800 text-center" data-translate="game_start_message"></p>
            <div id="hintsSection" class="w-full mt-4 p-4 bg-gray-50 rounded-lg border border-gray-200">
                <h3 id="hintsTitle" class="text-lg font-semibold text-gray-700 mb-2" data-translate="hints_title">Подсказки:</h3>
                <div id="hintsList" class="flex flex-col gap-2 text-sm text-gray-600"></div>
            </div>
            <div class="digit-picker">
                <div class="digit-slot">
                    <button class="digit-btn digit-up" data-slot="0">↑</button>
                    <div class="digit-display" data-slot="0">0</div>
                    <button class="digit-btn digit-down" data-slot="0">↓</button>
                </div>
                <div class="digit-slot">
                    <button class="digit-btn digit-up" data-slot="1">↑</button>
                    <div class="digit-display" data-slot="1">0</div>
                    <button class="digit-btn digit-down" data-slot="1">↓</button>
                </div>
                <div class="digit-slot">
                    <button class="digit-btn digit-up" data-slot="2">↑</button>
                    <div class="digit-display" data-slot="2">0</div>
                    <button class="digit-btn digit-down" data-slot="2">↓</button>
                </div>
            </div>
            <button id="breakButton" class="bg-blue-600 text-white font-bold py-3 px-8 rounded-full shadow-lg hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300 transform transition-transform duration-100 active:scale-95">
                <span id="breakButtonText" data-translate="break_button">Зламати</span>
            </button>
            <div id="attemptsDisplay" class="text-md text-gray-600 font-medium"></div>
            <div id="popup" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 hidden">
                <div class="bg-white rounded-lg p-6 shadow-2xl text-center">
                    <p id="popupMessage" class="text-lg font-semibold mb-4 text-gray-800"></p>
                    <button id="popupOkButton" class="bg-blue-600 text-white font-bold py-2 px-6 rounded-full hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300" data-translate="ok_button">Добре</button>
                </div>
            </div>
            <div id="newGameControls" class="w-full flex justify-center gap-4 mt-4">
                <button id="newGameButton" class="bg-indigo-600 text-white font-bold py-3 px-6 rounded-full shadow-lg hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-300 transform transition-transform duration-100 active:scale-95">
                    <span id="newGameButtonText" data-translate="new_game_button">Нова гра</span>
                </button>
            </div>
        </div>
    </div>
    <script>
        Telegram.WebApp.ready();
        Telegram.WebApp.expand();
        let translations = {};
        const supportedLanguages = {
            'en': 'English', 'ru': 'Русский', 'es': 'Español', 'pt': 'Português', 'de': 'Deutsch',
            'fr': 'Français', 'it': 'Italiano', 'ar': 'العربية', 'uk': 'Українська', 'id': 'Bahasa Indonesia'
        };
        let currentLanguage = localStorage.getItem('language') || (Telegram.WebApp.initDataUnsafe.user && Telegram.WebApp.initDataUnsafe.user.language_code) || 'en';
        let isDarkMode = localStorage.getItem('isDarkMode') === 'true';
        let isSoundEnabled = localStorage.getItem('isSoundEnabled') !== null ? (localStorage.getItem('isSoundEnabled') === 'true') : true;
        const Difficulty = {
            HARD: {
                displayNameKey: 'difficulty_hard',
                codeLength: 3,
                maxAttempts: 3,
                hintCost: 0,
                rewardRange: { min: 100, max: 1000 },
                unlockCost: 0
            }
        };
        let totalCoins = parseInt(localStorage.getItem('totalCoins')) || 0;
        let gamesPlayed = parseInt(localStorage.getItem('gamesPlayed')) || 0;
        let levelsCompleted = parseInt(localStorage.getItem('levelsCompleted')) || 0;
        let currentDifficultyKey = 'HARD';
        let secretCode = [];
        let attemptsLeft = Difficulty.HARD.maxAttempts;
        let gameActive = false;
        let hints = [];
        let rules = [];
        const appTitle = document.getElementById('appTitle');
        const totalCoinsDisplay = document.getElementById('totalCoinsDisplay');
        const gamesPlayedDisplay = document.getElementById('gamesPlayedDisplay');
        const levelsCompletedDisplay = document.getElementById('levelsCompletedDisplay');
        const rewardRangeDisplay = document.getElementById('rewardRangeDisplay');
        const messageDisplay = document.getElementById('messageDisplay');
        const breakButton = document.getElementById('breakButton');
        const attemptsDisplay = document.getElementById('attemptsDisplay');
        const hintsTitle = document.getElementById('hintsTitle');
        const hintsList = document.getElementById('hintsList');
        const popup = document.getElementById('popup');
        const popupMessage = document.getElementById('popupMessage');
        const popupOkButton = document.getElementById('popupOkButton');
        const newGameButton = document.getElementById('newGameButton');
        const newGameButtonText = document.getElementById('newGameButtonText');
        const difficultySelector = document.getElementById('difficultySelector');
        const languageSelector = document.getElementById('languageSelector');
        const themeToggleBtn = document.getElementById('themeToggleBtn');
        const themeIcon = document.getElementById('themeIcon');
        const soundToggleBtn = document.getElementById('soundToggleBtn');
        const soundOnIcon = document.getElementById('soundOnIcon');
        const soundOffIcon = document.getElementById('soundOffIcon');
        const digitDisplays = document.querySelectorAll('.digit-display');
        const digitUpButtons = document.querySelectorAll('.digit-up');
        const digitDownButtons = document.querySelectorAll('.digit-down');

        async function loadTranslations(lang) {
            try {
                const response = await fetch(`./locales/${lang}.json`);
                if (!response.ok) throw new Error(`Failed to load translation for ${lang}`);
                translations = await response.json();
                applyTranslations();
            } catch (error) {
                console.error(`[Localization Error] ${error.message}`);
                if (lang !== 'en') {
                    currentLanguage = 'en';
                    localStorage.setItem('language', 'en');
                    await loadTranslations('en');
                }
            }
        }

        function translate(key, params = {}) {
            let translation = translations[key] || key;
            for (const paramKey in params) {
                translation = translation.replace(`{${paramKey}}`, params[paramKey]);
            }
            return translation;
        }

        function applyTranslations() {
            document.querySelectorAll('[data-translate]').forEach(element => {
                element.textContent = translate(element.dataset.translate);
            });
            document.title = translate('app_title');
            Difficulty.HARD.displayName = translate('difficulty_hard');
            updateStatsDisplay();
            populateDifficultySelector();
            updateHintsDisplay();
        }

        function updateStatsDisplay() {
            totalCoinsDisplay.textContent = `${translate('total_coins')} ${totalCoins} SCG`;
            gamesPlayedDisplay.textContent = `${translate('games_played')} ${gamesPlayed}`;
            levelsCompletedDisplay.textContent = `${translate('levels_completed')} ${levelsCompleted}`;
            updateRewardRangeDisplay();
        }

        function updateRewardRangeDisplay() {
            const currentDiff = Difficulty[currentDifficultyKey];
            const tier = Math.floor(gamesPlayed / 10);
            const minReward = currentDiff.rewardRange.min + tier * 100;
            const maxReward = currentDiff.rewardRange.max + tier * 1000;
            rewardRangeDisplay.textContent = `${translate('reward_range')}: ${minReward}-${maxReward} SCG`;
        }

        function showPopup(messageKey, options = {}) {
            popupMessage.innerHTML = translate(messageKey, options);
            popup.classList.remove('hidden');
        }

        function hidePopup() {
            popup.classList.add('hidden');
        }

        function getReward() {
            const tier = Math.floor(gamesPlayed / 10);
            const minReward = 100 + tier * 100;
            const maxReward = 1000 + tier * 1000;
            return Math.floor(Math.random() * (maxReward - minReward + 1)) + minReward;
        }

        function generateSecretCode() {
            let answer;
            let attempts = 0;
            const maxAttempts = 100;
            while (attempts < maxAttempts) {
                answer = Math.floor(Math.random() * 1000);
                const answerStr = answer.toString().padStart(3, '0');
                if (new Set(answerStr).size === 3) {
                    return answerStr.split('').map(Number);
                }
                attempts++;
            }
            return [1, 2, 3];
        }

        function generateHints(answer) {
            const answerStr = answer.join('');
            const answerDigits = answer;
            const allDigits = new Set(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']);
            const rules = [
                [1, 1],
                [2, 1],
                [2, 0]
            ];
            shuffleArray(rules);
            const hints = [];
            const usedDigits = { '0': 0, '1': 0, '2': 0, '3': 0, '4': 0, '5': 0, '6': 0, '7': 0, '8': 0, '9': 0 };

            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            for (const rule of rules) {
                let hint = ['', '', ''];
                try {
                    if (rule[0] === 1 && rule[1] === 1) {
                        const availableDigits = answerDigits.filter(d => usedDigits[d] < 2);
                        if (!availableDigits.length) return null;
                        const correctDigit = availableDigits[Math.floor(Math.random() * availableDigits.length)];
                        const pos = answerDigits.indexOf(correctDigit);
                        hint[pos] = correctDigit.toString();
                        usedDigits[correctDigit]++;
                        for (let i = 0; i < 3; i++) {
                            if (hint[i] === '') {
                                const available = Array.from(allDigits).filter(d => usedDigits[d] < 2 && !answerDigits.includes(Number(d)));
                                if (!available.length) return null;
                                hint[i] = available[Math.floor(Math.random() * available.length)];
                                usedDigits[hint[i]]++;
                            }
                        }
                    } else if (rule[0] === 2 && rule[1] === 1) {
                        const availableDigits = answerDigits.filter(d => usedDigits[d] < 2);
                        if (availableDigits.length < 2) return null;
                        const correctDigits = sample(availableDigits, 2);
                        usedDigits[correctDigits[0]]++;
                        usedDigits[correctDigits[1]]++;
                        const correctPosDigit = correctDigits[Math.floor(Math.random() * 2)];
                        const correctPos = answerDigits.indexOf(correctPosDigit);
                        hint[correctPos] = correctPosDigit.toString();
                        const incorrectDigit = correctDigits[0] === correctPosDigit ? correctDigits[1] : correctDigits[0];
                        const possiblePos = [0, 1, 2].filter(i => i !== correctPos && i !== answerDigits.indexOf(incorrectDigit));
                        if (!possiblePos.length) return null;
                        hint[possiblePos[Math.floor(Math.random() * possiblePos.length)]] = incorrectDigit.toString();
                        for (let i = 0; i < 3; i++) {
                            if (hint[i] === '') {
                                const available = Array.from(allDigits).filter(d => usedDigits[d] < 2 && !answerDigits.includes(Number(d)));
                                if (!available.length) return null;
                                hint[i] = available[Math.floor(Math.random() * available.length)];
                                usedDigits[hint[i]]++;
                            }
                        }
                    } else if (rule[0] === 2 && rule[1] === 0) {
                        let availableDigits = answerDigits.filter(d => usedDigits[d] < 2);
                        if (availableDigits.length < 2) return null;
                        const digit1 = availableDigits[Math.floor(Math.random() * availableDigits.length)];
                        usedDigits[digit1]++;
                        availableDigits = answerDigits.filter(d => d !== digit1 && usedDigits[d] < 2);
                        if (!availableDigits.length) return null;
                        const digit2 = availableDigits[Math.floor(Math.random() * availableDigits.length)];
                        usedDigits[digit2]++;
                        const possiblePos1 = [0, 1, 2].filter(i => answerDigits[i] !== digit1);
                        if (!possiblePos1.length) return null;
                        const pos1 = possiblePos1[Math.floor(Math.random() * possiblePos1.length)];
                        hint[pos1] = digit1.toString();
                        const possiblePos2 = [0, 1, 2].filter(i => i !== pos1 && answerDigits[i] !== digit2);
                        if (!possiblePos2.length) return null;
                        const pos2 = possiblePos2[Math.floor(Math.random() * possiblePos2.length)];
                        hint[pos2] = digit2.toString();
                        for (let i = 0; i < 3; i++) {
                            if (hint[i] === '') {
                                const available = Array.from(allDigits).filter(d => usedDigits[d] < 2 && !answerDigits.includes(Number(d)));
                                if (!available.length) return null;
                                hint[i] = available[Math.floor(Math.random() * available.length)];
                                usedDigits[hint[i]]++;
                            }
                        }
                    }
                    const hintStr = hint.join('');
                    if (new Set(hintStr).size !== 3 || hintStr === answerStr) return null;
                    hints.push(hintStr);
                } catch (e) {
                    console.error(`Error generating hint for rule ${rule}: ${e}`);
                    return null;
                }
            }

            if (!checkUniqueSolution(hints, rules)) return null;
            return { hints, rules };

            function sample(array, n) {
                const shuffled = [...array].sort(() => Math.random() - 0.5);
                return shuffled.slice(0, n);
            }
        }

        function checkUniqueSolution(hints, rules) {
            try {
                const solutions = [];
                for (let i = 0; i < 1000; i++) {
                    const candidate = i.toString().padStart(3, '0');
                    if (new Set(candidate).size === 3) {
                        let isSolution = true;
                        for (let j = 0; j < hints.length; j++) {
                            let correctPos = 0;
                            let correctDigits = 0;
                            for (let k = 0; k < 3; k++) {
                                if (hints[j][k] === candidate[k]) correctPos++;
                                if (candidate.includes(hints[j][k])) correctDigits++;
                            }
                            if (!(correctDigits === rules[j][0] && correctPos === rules[j][1])) {
                                isSolution = false;
                                break;
                            }
                        }
                        if (isSolution) solutions.push(candidate);
                    }
                }
                return solutions.length === 1 && solutions[0] === secretCode.join('');
            } catch (e) {
                console.error(`Error checking unique solution: ${e}`);
                return false;
            }
        }

        function resetGame() {
            const currentDiff = Difficulty[currentDifficultyKey];
            let result = null;
            let attempts = 0;
            const maxAttempts = 100;
            while (!result && attempts < maxAttempts) {
                secretCode = generateSecretCode();
                result = generateHints(secretCode);
                attempts++;
            }
            if (!result) {
                showPopup('puzzle_generation_failed');
                return;
            }
            hints = result.hints;
            rules = result.rules;
            attemptsLeft = currentDiff.maxAttempts;
            gameActive = true;
            resetDigitPicker();
            updateAttemptsDisplay();
            updateHintsDisplay();
            messageDisplay.textContent = translate('guess_code_message', { codeLength: currentDiff.codeLength });
            breakButton.disabled = false;
        }

        function updateHintsDisplay() {
            hintsList.innerHTML = '';
            const descriptions = {
                '1,1': translate('hint_one_correct_position'),
                '2,1': translate('hint_two_correct_one_position'),
                '2,0': translate('hint_two_correct_none_position')
            };
            hints.forEach((hint, i) => {
                const hintItem = document.createElement('p');
                hintItem.classList.add('bg-blue-100', 'text-blue-800', 'px-3', 'py-1', 'rounded-full');
                hintItem.textContent = `${hint} ${descriptions[rules[i].join(',')]}`;
                hintsList.appendChild(hintItem);
            });
        }

        function resetDigitPicker() {
            digitDisplays.forEach((display, index) => {
                display.textContent = '0';
                updateDigitButtons(index);
            });
        }

        function updateDigitButtons(slot) {
            const currentValue = Number(digitDisplays[slot].textContent);
            const otherValues = Array.from(digitDisplays)
                .map(d => Number(d.textContent))
                .filter((_, i) => i !== slot);
            const upBtn = digitUpButtons[slot];
            const downBtn = digitDownButtons[slot];
            upBtn.disabled = currentValue === 9 || otherValues.includes(currentValue + 1);
            downBtn.disabled = currentValue === 0 || otherValues.includes(currentValue - 1);
        }

        function checkGuess() {
            if (!gameActive) return;
            const guess = Array.from(digitDisplays).map(d => d.textContent).join('');
            if (new Set(guess).size !== 3) {
                messageDisplay.textContent = translate('guess_code_message', { codeLength: 3 });
                return;
            }
            attemptsLeft--;
            updateAttemptsDisplay();
            if (guess === secretCode.join('')) {
                gameActive = false;
                gamesPlayed++;
                levelsCompleted++;
                localStorage.setItem('gamesPlayed', gamesPlayed);
                localStorage.setItem('levelsCompleted', levelsCompleted);
                const reward = getReward();
                totalCoins += reward;
                localStorage.setItem('totalCoins', totalCoins);
                updateStatsDisplay();
                showPopup('safe_cracked_win', { earnedCoins: reward, levelsCompleted: levelsCompleted });
                if (levelsCompleted % 10 === 0) {
                    showPopup('milestone_reached', { levelsCompleted: levelsCompleted });
                }
            } else if (attemptsLeft <= 0) {
                gameActive = false;
                gamesPlayed++;
                localStorage.setItem('gamesPlayed', gamesPlayed);
                showPopup('game_over_message', { secretCode: secretCode.join('') });
                setTimeout(() => {
                    resetGame();
                    hidePopup();
                }, 1000);
            } else {
                messageDisplay.textContent = translate('incorrect_guess_message', { attemptsLeft: attemptsLeft });
            }
        }

        function updateAttemptsDisplay() {
            attemptsDisplay.textContent = translate('attempts_left_message', { attemptsLeft: attemptsLeft });
        }

        function saveGameData() {
            localStorage.setItem('totalCoins', totalCoins);
            localStorage.setItem('gamesPlayed', gamesPlayed);
            localStorage.setItem('levelsCompleted', levelsCompleted);
            localStorage.setItem('currentDifficulty', currentDifficultyKey);
            localStorage.setItem('isSoundEnabled', isSoundEnabled);
            localStorage.setItem('isDarkMode', isDarkMode);
        }

        function loadGameData() {
            totalCoins = parseInt(localStorage.getItem('totalCoins')) || 0;
            gamesPlayed = parseInt(localStorage.getItem('gamesPlayed')) || 0;
            levelsCompleted = parseInt(localStorage.getItem('levelsCompleted')) || 0;
            currentDifficultyKey = localStorage.getItem('currentDifficulty') || 'HARD';
            isSoundEnabled = localStorage.getItem('isSoundEnabled') !== null ? (localStorage.getItem('isSoundEnabled') === 'true') : true;
            isDarkMode = localStorage.getItem('isDarkMode') === 'true';
        }

        function populateLanguageSelector() {
            languageSelector.innerHTML = '';
            for (const langCode in supportedLanguages) {
                const option = document.createElement('option');
                option.value = langCode;
                option.textContent = supportedLanguages[langCode];
                languageSelector.appendChild(option);
            }
            languageSelector.value = currentLanguage;
        }

        function populateDifficultySelector() {
            difficultySelector.innerHTML = '';
            const option = document.createElement('option');
            option.value = 'HARD';
            option.textContent = translate('difficulty_hard');
            difficultySelector.appendChild(option);
            difficultySelector.value = currentDifficultyKey;
        }

        function applyTheme() {
            if (isDarkMode) {
                document.body.classList.add('dark-mode');
                document.querySelector('.game-container').classList.add('dark-mode');
                themeIcon.innerHTML = `<path d="M12 2.5a.5.5 0 01.5.5v1a.5.5 0 01-1 0V3a.5.5 0 01.5-.5zM12 19.5a.5.5 0 01-.5-.5v-1a.5.5 0 011 0v1a.5.5 0 01-.5.5zM3.866 5.134a.5.5 0 01-.354-.854l.708-.708a.5.5 0 01.708.708l-.708.708a.5.5 0 01-.354.146zM19.485 18.985a.5.5 0 01-.354-.146l-.708-.708a.5.5 0 01.708-.708l.708.708a.5.5 0 01-.354.854zM2.5 12a.5.5 0 01.5-.5h1a.5.5 0 010 1h-1a.5.5 0 01-.5-.5zM19.5 12a.5.5 0 01.5-.5h1a.5.5 0 010 1h-1a.5.5 0 01-.5-.5zM3.866 18.985a.5.5 0 01-.354-.146l-.708-.708a.5.5 0 01.708-.708l.708.708a.5.5 0 01-.354.854zM19.485 5.134a.5.5 0 01-.354-.854l.708-.708a.5.5 0 01.708.708l-.708.708a.5.5 0 01-.354.146zM12 7a5 5 0 100 10 5 5 0 000-10z"/>`;
                themeIcon.classList.remove('text-gray-700', 'text-purple-300');
                themeIcon.classList.add('text-yellow-500');
            } else {
                document.body.classList.remove('dark-mode');
                document.querySelector('.game-container').classList.remove('dark-mode');
                themeIcon.innerHTML = `<path d="M12 3a9 9 0 109 9c0-.46-.03-.92-.1-1.37a.75.75 0 01.62-.83c.7-.13 1.36-.26 2-.43A10.5 10.5 0 0112 22.5c-5.8 0-10.5-4.7-10.5-10.5S6.2 1.5 12 1.5c1.86 0 3.63.48 5.2 1.37a.75.75 0 01.62.83c-.07.45-.1.91-.1 1.37a9 9 0 00-6.7-1.37z"/>`;
                themeIcon.classList.remove('text-yellow-500');
                themeIcon.classList.add('text-gray-700');
            }
            localStorage.setItem('isDarkMode', isDarkMode);
        }

        function toggleTheme() {
            isDarkMode = !isDarkMode;
            applyTheme();
        }

        function updateSoundIcon() {
            if (isSoundEnabled) {
                soundOnIcon.classList.remove('hidden');
                soundOffIcon.classList.add('hidden');
            } else {
                soundOnIcon.classList.add('hidden');
                soundOffIcon.classList.remove('hidden');
            }
            localStorage.setItem('isSoundEnabled', isSoundEnabled);
        }

        function toggleSound() {
            isSoundEnabled = !isSoundEnabled;
            updateSoundIcon();
        }

        digitUpButtons.forEach(button => {
            button.addEventListener('click', () => {
                const slot = Number(button.dataset.slot);
                let value = Number(digitDisplays[slot].textContent);
                const otherValues = Array.from(digitDisplays)
                    .map(d => Number(d.textContent))
                    .filter((_, i) => i !== slot);
                while (value < 9 && otherValues.includes(value + 1)) {
                    value++;
                }
                if (value < 9) {
                    digitDisplays[slot].textContent = (value + 1).toString();
                    updateDigitButtons(slot);
                    for (let i = 0; i < 3; i++) {
                        if (i !== slot) updateDigitButtons(i);
                    }
                }
            });
        });

        digitDownButtons.forEach(button => {
            button.addEventListener('click', () => {
                const slot = Number(button.dataset.slot);
                let value = Number(digitDisplays[slot].textContent);
                const otherValues = Array.from(digitDisplays)
                    .map(d => Number(d.textContent))
                    .filter((_, i) => i !== slot);
                while (value > 0 && otherValues.includes(value - 1)) {
                    value--;
                }
                if (value > 0) {
                    digitDisplays[slot].textContent = (value - 1).toString();
                    updateDigitButtons(slot);
                    for (let i = 0; i < 3; i++) {
                        if (i !== slot) updateDigitButtons(i);
                    }
                }
            });
        });

        breakButton.addEventListener('click', checkGuess);
        newGameButton.addEventListener('click', () => {
            resetGame();
            hidePopup();
        });
        popupOkButton.addEventListener('click', hidePopup);
        difficultySelector.addEventListener('change', () => {
            currentDifficultyKey = difficultySelector.value;
            localStorage.setItem('currentDifficulty', currentDifficultyKey);
            resetGame();
            saveGameData();
        });
        languageSelector.addEventListener('change', async (event) => {
            currentLanguage = event.target.value;
            localStorage.setItem('language', currentLanguage);
            await loadTranslations(currentLanguage);
            resetGame();
            saveGameData();
        });
        themeToggleBtn.addEventListener('click', toggleTheme);
        soundToggleBtn.addEventListener('click', toggleSound);

        document.addEventListener('DOMContentLoaded', async () => {
            loadGameData();
            applyTheme();
            updateSoundIcon();
            await loadTranslations(currentLanguage);
            populateLanguageSelector();
            populateDifficultySelector();
            resetGame();
        });
    </script>
</body>
</html>
